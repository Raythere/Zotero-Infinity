import type { PaperContext } from "./pdf-extract";
import { getItemMetadata, getAttachmentText, getPdfAttachments } from "./pdf-extract";
import * as OllamaAPI from "./ollama-api";
import type { ChatMessage } from "./ollama-api";

declare const Zotero: any;

const DEFAULT_MODEL = "llama3.2:1b";

// ── Export Chat as Note ──────────────────────────────────────────

export function formatChatAsHTML(
  papers: PaperContext[],
  messages: ChatMessage[],
): string {
  const lines: string[] = [];

  lines.push("<h2>AI Chat Notes</h2>");
  lines.push(`<p><em>Generated by Zotero Infinity on ${new Date().toLocaleDateString()}</em></p>`);

  if (papers.length > 0) {
    lines.push("<h3>Papers discussed</h3><ul>");
    for (const p of papers) {
      lines.push(`<li><strong>${escHTML(p.title)}</strong>${p.authors ? ` — ${escHTML(p.authors)}` : ""}${p.year ? ` (${p.year})` : ""}</li>`);
    }
    lines.push("</ul><hr/>");
  }

  lines.push("<h3>Conversation</h3>");
  for (const m of messages) {
    if (m.role === "system") continue;
    if (m.role === "user") {
      lines.push(`<p><strong>You:</strong></p><blockquote>${escHTML(m.content)}</blockquote>`);
    } else if (m.role === "assistant") {
      lines.push(`<p><strong>AI:</strong></p><p>${escHTML(m.content)}</p>`);
    }
  }

  return lines.join("\n");
}

export async function saveChatAsNote(
  parentItemId: number | null,
  papers: PaperContext[],
  messages: ChatMessage[],
): Promise<void> {
  const html = formatChatAsHTML(papers, messages);
  const note = new Zotero.Item("note");

  if (parentItemId) {
    note.parentID = parentItemId;
  }

  note.setNote(html);
  await note.saveTx();
  Zotero.debug(`[zotero-local-ai] Chat saved as note (id=${note.id})`);
}

// ── Library-Wide Semantic Search ─────────────────────────────────

interface SearchResult {
  item: any;
  title: string;
  authors: string;
  year: string;
  abstract: string;
  score: number;
}

export async function searchLibrary(
  query: string,
  maxResults = 10,
): Promise<SearchResult[]> {
  const libraryID = Zotero.Libraries.userLibraryID;

  // Get all regular items from the library
  const s = new Zotero.Search();
  s.libraryID = libraryID;
  s.addCondition("itemType", "isNot", "attachment");
  s.addCondition("itemType", "isNot", "note");

  const ids: number[] = await s.search();
  if (!ids || ids.length === 0) return [];

  const items = await Zotero.Items.getAsync(ids);
  if (!items || !Array.isArray(items)) return [];

  const queryLower = query.toLowerCase();
  const words = queryLower.split(/\s+/).filter(Boolean);
  const scored: SearchResult[] = [];

  for (const item of items) {
    if (!item?.isRegularItem?.()) continue;

    try {
      const meta = getItemMetadata(item);
      const title = (meta.title || "").toLowerCase();
      const authors = (meta.authors || "").toLowerCase();
      const abstract = (meta.abstract || "").toLowerCase();
      const year = meta.year || "";
      const tags = (item.getTags?.() || []).map((t: any) => (t.tag || "").toLowerCase()).join(" ");

      // Try to get PDF full text for deep search
      let fullText = "";
      try {
        const pdfs = getPdfAttachments(item);
        for (const att of pdfs) {
          const t = await getAttachmentText(att);
          if (t) { fullText = t.toLowerCase().slice(0, 20000); break; }
        }
      } catch {
        // no text available
      }

      let score = 0;
      for (const w of words) {
        if (title.includes(w)) score += 5;
        if (authors.includes(w)) score += 4;
        if (abstract.includes(w)) score += 3;
        if (tags.includes(w)) score += 2;
        if (year.includes(w)) score += 1;
        if (fullText.includes(w)) score += 1;
      }

      if (score > 0) {
        scored.push({
          item,
          title: meta.title,
          authors: meta.authors,
          year: meta.year,
          abstract: meta.abstract,
          score,
        });
      }
    } catch {
      // skip
    }
  }

  scored.sort((a, b) => b.score - a.score);
  return scored.slice(0, maxResults);
}

export async function librarySearchWithAI(
  query: string,
  onToken?: (token: string) => void,
): Promise<{ answer: string; results: SearchResult[] }> {
  const results = await searchLibrary(query, 8);

  if (results.length === 0) {
    return { answer: "No papers found in your library matching that query.", results: [] };
  }

  const context = results.map((r, i) =>
    `[${i + 1}] "${r.title}"${r.authors ? ` by ${r.authors}` : ""}${r.year ? ` (${r.year})` : ""}\n${r.abstract ? `Abstract: ${r.abstract.slice(0, 500)}` : "(no abstract)"}`
  ).join("\n\n");

  const messages: ChatMessage[] = [
    {
      role: "system",
      content: `You are a research librarian AI inside Zotero. The user searched their paper library. Below are the matching papers with their abstracts. Answer the user's question using ONLY these papers. Reference papers by their number [1], [2] etc. Be concise and specific.\n\n${context}`,
    },
    { role: "user", content: query },
  ];

  const answer = await OllamaAPI.chat(DEFAULT_MODEL, messages, onToken);
  return { answer, results };
}

// ── Get all library items ────────────────────────────────────────

export async function getAllLibraryItems(): Promise<
  { item: any; title: string; authors: string; year: string; abstract: string }[]
> {
  const libraryID = Zotero.Libraries.userLibraryID;
  const s = new Zotero.Search();
  s.libraryID = libraryID;
  s.addCondition("itemType", "isNot", "attachment");
  s.addCondition("itemType", "isNot", "note");

  const ids: number[] = await s.search();
  if (!ids || ids.length === 0) return [];

  const items = await Zotero.Items.getAsync(ids);
  if (!items || !Array.isArray(items)) return [];

  const results: { item: any; title: string; authors: string; year: string; abstract: string }[] = [];
  for (const item of items) {
    if (!item?.isRegularItem?.()) continue;
    try {
      const meta = getItemMetadata(item);
      results.push({
        item,
        title: meta.title || "Untitled",
        authors: meta.authors || "",
        year: meta.year || "",
        abstract: meta.abstract || "",
      });
    } catch { /* skip */ }
  }
  return results;
}

// ── Categorize papers by similarity ──────────────────────────────

export interface PaperCategory {
  category: string;
  papers: { title: string; authors: string; year: string; item: any }[];
}

export async function categorizePapers(
  papers: { item: any; title: string; authors: string; year: string; abstract: string }[],
  onToken?: (token: string) => void,
): Promise<PaperCategory[]> {
  if (papers.length === 0) return [];

  const summaries = papers.slice(0, 50).map((p, i) =>
    `[${i + 1}] "${p.title}"${p.authors ? ` by ${p.authors}` : ""}${p.year ? ` (${p.year})` : ""}${p.abstract ? `\n  Abstract: ${p.abstract.slice(0, 200)}` : ""}`
  ).join("\n");

  const messages: ChatMessage[] = [
    {
      role: "system",
      content:
        "You are a research librarian. Given a list of papers, group them into categories based on similarity (topic, methodology, field). " +
        "Output ONLY a structured list in this exact format, nothing else:\n\n" +
        "CATEGORY: <category name>\nPAPERS: <comma-separated paper numbers>\n\n" +
        "CATEGORY: <category name>\nPAPERS: <comma-separated paper numbers>\n\n" +
        "Each paper should appear in exactly one category. Use 2-6 categories. Category names should be short (2-5 words).",
    },
    { role: "user", content: summaries },
  ];

  const reply = await OllamaAPI.chat(DEFAULT_MODEL, messages, onToken);

  const categories: PaperCategory[] = [];
  const blocks = reply.split(/\n\s*\n|\nCATEGORY:/i);

  for (const block of blocks) {
    const catMatch = block.match(/(?:CATEGORY:\s*)?(.+)/i);
    const papersMatch = block.match(/PAPERS:\s*(.+)/i);
    if (!catMatch || !papersMatch) continue;

    const catName = catMatch[1].replace(/^CATEGORY:\s*/i, "").trim();
    if (!catName) continue;

    const nums = papersMatch[1]
      .split(/[,;\s]+/)
      .map((n) => parseInt(n.replace(/[[\]]/g, ""), 10))
      .filter((n) => !isNaN(n) && n >= 1 && n <= papers.length);

    if (nums.length === 0) continue;

    categories.push({
      category: catName.toLowerCase(),
      papers: nums.map((n) => ({
        title: papers[n - 1].title,
        authors: papers[n - 1].authors,
        year: papers[n - 1].year,
        item: papers[n - 1].item,
      })),
    });
  }

  return categories;
}

// ── Compare papers with AI ───────────────────────────────────────

export async function comparePapers(
  papers: { title: string; authors: string; year: string; abstract: string; text?: string }[],
  onToken?: (token: string) => void,
): Promise<string> {
  if (papers.length < 2) return "Select at least 2 papers to compare.";

  const summaries = papers.map((p, i) => {
    const textSnippet = p.text ? p.text.slice(0, 2000) : "";
    return (
      `--- Paper ${i + 1} ---\n` +
      `Title: ${p.title}\n` +
      (p.authors ? `Authors: ${p.authors}\n` : "") +
      (p.year ? `Year: ${p.year}\n` : "") +
      (p.abstract ? `Abstract: ${p.abstract}\n` : "") +
      (textSnippet ? `Text excerpt: ${textSnippet}\n` : "")
    );
  }).join("\n");

  const messages: ChatMessage[] = [
    {
      role: "system",
      content:
        "You are a research paper analyst. Compare the given papers and provide:\n" +
        "1. A brief summary of each paper (2-3 sentences)\n" +
        "2. Key similarities between them\n" +
        "3. Key differences between them\n" +
        "4. How they relate to each other\n" +
        "Be concise but thorough. Reference papers by their number [1], [2], etc.",
    },
    { role: "user", content: `Compare these papers:\n\n${summaries}` },
  ];

  return await OllamaAPI.chat(DEFAULT_MODEL, messages, onToken);
}

// ── Smart Auto-Tagging ──────────────────────────────────────────

export async function suggestTags(
  item: any,
  onToken?: (token: string) => void,
): Promise<string[]> {
  const meta = getItemMetadata(item);

  let textSnippet = "";
  try {
    const pdfs = getPdfAttachments(item);
    if (pdfs.length > 0) {
      const t = await getAttachmentText(pdfs[0]);
      textSnippet = t.slice(0, 3000);
    }
  } catch {
    // no text available
  }

  const paperInfo =
    `Title: ${meta.title}\n` +
    (meta.authors ? `Authors: ${meta.authors}\n` : "") +
    (meta.abstract ? `Abstract: ${meta.abstract}\n` : "") +
    (textSnippet ? `Text excerpt: ${textSnippet}\n` : "");

  const messages: ChatMessage[] = [
    {
      role: "system",
      content: "You are a research paper classifier. Given a paper's metadata and text, suggest 3-7 descriptive tags. Output ONLY the tags as a comma-separated list, nothing else. Tags should be lowercase, concise (1-3 words each), and cover the paper's topic, methodology, and field.",
    },
    { role: "user", content: paperInfo },
  ];

  const reply = await OllamaAPI.chat(DEFAULT_MODEL, messages, onToken);

  return reply
    .split(",")
    .map((t) => t.trim().toLowerCase().replace(/[.'"]/g, ""))
    .filter((t) => t.length > 1 && t.length < 50);
}

export async function applyTags(item: any, tags: string[]): Promise<void> {
  for (const tag of tags) {
    item.addTag(tag, 0);
  }
  await item.saveTx();
  Zotero.debug(`[zotero-local-ai] Applied ${tags.length} tags to "${item.getField?.("title")}"`);
}

// ── Helpers ──────────────────────────────────────────────────────

function escHTML(s: string): string {
  return s
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}
